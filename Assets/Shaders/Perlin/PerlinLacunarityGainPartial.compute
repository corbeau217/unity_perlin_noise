#define blockWidth 16
#define blockHeight 16
#define noiseregionsize 100

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PerlinLacunarityGainPartial

// ==================================================
// ==================================================

float bilinearInterpolation(float bottomLeft, float bottomRight, float topLeft, float topRight, float2 t){
    // ==== X then Y ====

    // 1 dimensional interpolation across X axis
    float linearBottom = lerp(bottomLeft,bottomRight,t.x);
    float linearTop = lerp(topLeft,topRight,t.x);

    // now interpolate them together to make it 2D
    //  but save it as a variable first because otherwise it does weird stuff during compilation?
    float bilinearXY = lerp(linearBottom,linearTop,t.y);

    // ==== Y then X ====

    // 1 dimensional interpolation across Y axis
    float linearLeft = lerp(bottomLeft,topLeft,t.y);
    float linearRight = lerp(bottomRight,topRight,t.y);

    // now interpolate them together to make it 2D
    //  but save it as a variable first because otherwise it does weird stuff during compilation?
    float bilinearYX = lerp(linearLeft,linearRight,t.x);

    // ==== XY and YX
    float average = (bilinearXY + bilinearYX)/2.0;

    return bilinearXY;
}

// quintic curve from 2002 paper
float smoothFunction(float t){
    return ((6.0*t - 15.0)*t + 10.0)*t*t*t;
}

float2 inputNoiseAsVector(float4 inputNoiseColour){
    // rounded to 6 decimal places because otherwise it doesnt compile
    float piValue = 3.141593;
    // location we are on the circle in radians from 0 to 2*pi
    float noiseRadians = inputNoiseColour.x * piValue * 2.0;

    // turn them in to vectors using trig (lazy)
    float2 resultVector = float2( cos(noiseRadians), sin(noiseRadians) );

    return resultVector;
}

// ==================================================
// ==================================================

// gridSpaceFraction
//      is our octave space uv coords, after performing the matrix multiplication set
// cornerOffset
//      is relative to the bottom left corner
// inputNoiseTexture
//      is the texture to sample our noise from
// inputTextureDimensions
//      is the size of the input noise texture
float GetCornerContribution(float2 gridSpaceFraction, float2 cornerOffset, float2 cellUVCoords, RWTexture2D<float4> inputNoiseTexture, uint2 inputTextureDimensions){
    // ======= get the corner vector =======

    // prepare the cell corner pixel location in our input noise
    //  this is where the vectors are
    //  (we include our corner offset in our pixel selecting decision)
    uint2 cellCornerVector_pixel  = uint2( floor(gridSpaceFraction.x+cornerOffset.x)%inputTextureDimensions.x, floor(gridSpaceFraction.y+cornerOffset.y)%inputTextureDimensions.y );

    // get the raw colours
    float4 cellCornerVector_colour  = inputNoiseTexture[cellCornerVector_pixel.xy];

    // turn them in to vectors using trig (lazy)
    float2 cellCornerVector  = inputNoiseAsVector(cellCornerVector_colour);

    // ======= get cell uv difference vector =======

    //  this is the vectors from each corner to where we are in the cell
    float2 cornerUVDifference  = float2(cornerOffset.x - cellUVCoords.x, cornerOffset.y - cellUVCoords.y);

    // ======= get resulting dot product =======
    
    // dot products of difference vector to cooresponding corner vector
    //  we also multiply the UV difference by 2 because our result seems to be in the range of [-0.5,0.5] otherwise
    float resultValue = dot( cornerUVDifference, cellCornerVector );
    
    return resultValue;
}

// this is the bulk of our noise fetching code
//  we move this to a separate function so we dont have to repeat each of these lines in subsequent octaves
//  outputing just the noise value at the end instead of a colour
float GetOctaveNoise(float4x4 octaveUVTransformationMatrix, float2 octaveCellCounts, float4 fragCoords, RWTexture2D<float4> inputNoiseTexture, uint2 inputTextureDimensions){
    
    // using matrix math to fetch our octave's grid location using our supplied transformation matrix
    float4 octaveGridSpaceCoord = mul( octaveUVTransformationMatrix, fragCoords );

    // we do this to preemptively solve any issues during indexing that might happen in really high resolution noise sampling
    //  where our position might slightly be over the number of cells we want, also to wrap our octave's grid 
    //  (remove these two lines if you dont want the octave corners to wrap around in their grid spaces)
    octaveGridSpaceCoord.x = octaveGridSpaceCoord.x%octaveCellCounts.x;
    octaveGridSpaceCoord.y = octaveGridSpaceCoord.y%octaveCellCounts.y;


    // now find the cell locations
    // the ends should still continue all the way up to 0.999999999999 and then go back to 0.0 anyway
    float2 cellUVCoords = float2( octaveGridSpaceCoord.x%1.0, octaveGridSpaceCoord.y%1.0 );
    // this is for interpolating our corners together
    float2 smoothCellUVCoords = float2(smoothFunction(cellUVCoords.x),smoothFunction(cellUVCoords.y));

    // ======= get cell uv difference vectors ====

    // get the corner vectors in "cell UV space"
    float2 cornerUVLocation_bottomLeft  = float2( 0.0, 0.0 );
    float2 cornerUVLocation_bottomRight = float2( 1.0, 0.0 );
    float2 cornerUVLocation_topLeft     = float2( 0.0, 1.0 );
    float2 cornerUVLocation_topRight    = float2( 1.0, 1.0 );

    // ======= get corner contributions ====
    // use da function we made
    float contribution1_bottomLeft  = GetCornerContribution( octaveGridSpaceCoord.xy, cornerUVLocation_bottomLeft, cellUVCoords, inputNoiseTexture, inputTextureDimensions );
    float contribution1_bottomRight = GetCornerContribution( octaveGridSpaceCoord.xy, cornerUVLocation_bottomRight, cellUVCoords, inputNoiseTexture, inputTextureDimensions );
    float contribution1_topLeft     = GetCornerContribution( octaveGridSpaceCoord.xy, cornerUVLocation_topLeft, cellUVCoords, inputNoiseTexture, inputTextureDimensions );
    float contribution1_topRight    = GetCornerContribution( octaveGridSpaceCoord.xy, cornerUVLocation_topRight, cellUVCoords, inputNoiseTexture, inputTextureDimensions );

    // ======= interpolate our 4 values ====

    float dotsInterpolated = bilinearInterpolation( contribution1_bottomLeft, contribution1_bottomRight, contribution1_topLeft, contribution1_topRight, smoothCellUVCoords );

    return dotsInterpolated;
}


// ==================================================
// ==================================================


RWTexture2D<float4> ResultImage;
int textureWidth;
int textureHeight;

RWTexture2D<float4> InputNoiseImage;
int noiseTextureWidth;
int noiseTextureHeight;

// we use this as a transformation matrix to quickly modify the
// uv coordinated of our octave noise input
float4x4 octaveUVMatrix1;
float4x4 octaveUVMatrix2;
float4x4 octaveUVMatrix3;
float4x4 octaveUVMatrix4;
float4x4 octaveUVMatrix5;

// cells which we have vectors at the corners
float2 cellCounts1;
float2 cellCounts2;
float2 cellCounts3;
float2 cellCounts4;
float2 cellCounts5;

float octaveContribution1;
float octaveContribution2;
float octaveContribution3;
float octaveContribution4;
float octaveContribution5;


// TODO fix to use these for amplitude/frequency/contribution

float2 cellCountInitial;
float amplitudeInitial;

float octaveLacunarity;
float octaveGain;

int divideByTotalContribution;
int uncenterNoiseValues;



[numthreads(blockWidth,blockHeight,1)]
void PerlinLacunarityGainPartial (uint3 id : SV_DispatchThreadID)
{
    // TODO : have something to check if we're outside the output dimensions
    // convert to floats, we dont like doing that mid equation?
    float2 texelLocation = float2( id.x, id.y);
    float2 outputResolution = float2( textureWidth, textureHeight);

    // to make sure we're retreiving our data correctly
    uint2 inputTextureDimensions = uint2( noiseTextureWidth, noiseTextureHeight );

    // find where we are in the output texture's uv space
    float4 fragmentCoords = float4( (texelLocation.x / outputResolution.x), (texelLocation.y / outputResolution.y), 0.0, 1.0 );

    // request the noise for that octave
    float octaveNoise1 = GetOctaveNoise( octaveUVMatrix1, cellCounts1, fragmentCoords, InputNoiseImage, inputTextureDimensions);
    float octaveNoise2 = GetOctaveNoise( octaveUVMatrix2, cellCounts2, fragmentCoords, InputNoiseImage, inputTextureDimensions);
    float octaveNoise3 = GetOctaveNoise( octaveUVMatrix3, cellCounts3, fragmentCoords, InputNoiseImage, inputTextureDimensions);
    float octaveNoise4 = GetOctaveNoise( octaveUVMatrix4, cellCounts4, fragmentCoords, InputNoiseImage, inputTextureDimensions);
    float octaveNoise5 = GetOctaveNoise( octaveUVMatrix5, cellCounts5, fragmentCoords, InputNoiseImage, inputTextureDimensions);

    // // move to [0.0,1.0] range 
    // octaveNoise1 = (octaveNoise1+1.0)/2.0;
    // octaveNoise2 = (octaveNoise2+1.0)/2.0;
    // octaveNoise3 = (octaveNoise3+1.0)/2.0;
    
    
    // speaking in ratios, we just say these are our terms of the overall mixing ratio
    float octaveTerm1 = octaveNoise1 * octaveContribution1;
    float octaveTerm2 = octaveNoise2 * octaveContribution2;
    float octaveTerm3 = octaveNoise3 * octaveContribution3;
    float octaveTerm4 = octaveNoise4 * octaveContribution4;
    float octaveTerm5 = octaveNoise5 * octaveContribution5;
    
    float mixedNoise = (octaveNoise1+octaveNoise2+octaveNoise3+octaveNoise4+octaveNoise5);

    // normalising it?
    float octaveRatioTotal = octaveContribution1 + octaveContribution2 + octaveContribution3 + octaveContribution4 + octaveContribution5;
    // only when it was requested, otherwise stay the same
    mixedNoise = (divideByTotalContribution > 0)? (mixedNoise/octaveRatioTotal) : (mixedNoise); // only when it was requested
    
    // bring to [0.0,1.0] range
    // only when it was requested, otherwise stay the same
    mixedNoise = (uncenterNoiseValues > 0)? ( (mixedNoise+1.0)/2.0 ) : (mixedNoise);
    

    // red is negative
    // green is positive
    // blue is more than 1.0 or less than -1.0
    // float4 outputColour = float4(abs(min(mixedNoise,0.0)),max(mixedNoise,0.0),((mixedNoise>1.0||mixedNoise<-1.0)?abs(mixedNoise)-1.0:0.0),1.0);
    // float4 outputColour = float4(0.0,0.0,((mixedNoise>1.0||mixedNoise<-1.0)?abs(mixedNoise)-1.0:0.0)*5.0,1.0);
    float4 outputColour = float4(mixedNoise,mixedNoise,mixedNoise,1.0);

    // save it
    ResultImage[id.xy] = outputColour;
}
