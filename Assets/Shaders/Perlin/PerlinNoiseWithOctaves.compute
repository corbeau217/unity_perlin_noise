#define blockWidth 16
#define blockHeight 16
#define noiseregionsize 100

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PerlinNoiseWithOctaves

// ==================================================
// ==================================================

float bilinearInterpolation(float bottomLeft, float bottomRight, float topLeft, float topRight, float2 t){
    // ==== X then Y ====

    // 1 dimensional interpolation across X axis
    float linearBottom = lerp(bottomLeft,bottomRight,t.x);
    float linearTop = lerp(topLeft,topRight,t.x);

    // now interpolate them together to make it 2D
    //  but save it as a variable first because otherwise it does weird stuff during compilation?
    float bilinearXY = lerp(linearBottom,linearTop,t.y);

    // ==== Y then X ====

    // 1 dimensional interpolation across Y axis
    float linearLeft = lerp(bottomLeft,topLeft,t.y);
    float linearRight = lerp(bottomRight,topRight,t.y);

    // now interpolate them together to make it 2D
    //  but save it as a variable first because otherwise it does weird stuff during compilation?
    float bilinearYX = lerp(linearLeft,linearRight,t.x);

    // ==== XY and YX
    float average = (bilinearXY + bilinearYX)/2.0;

    return bilinearXY;
}

float smoothFunction(float t){
    return ((6.0*t - 15.0)*t + 10.0)*t*t*t;
}

float2 inputNoiseAsVector(float4 inputNoiseColour){
    // rounded to 6 decimal places because otherwise it doesnt compile
    float piValue = 3.141593;
    // location we are on the circle in radians from 0 to 2*pi
    float noiseRadians = inputNoiseColour.x * piValue * 2.0;

    // turn them in to vectors using trig (lazy)
    float2 resultVector = float2( cos(noiseRadians), sin(noiseRadians) );

    return resultVector;
}

// ==================================================
// ==================================================

// gridSpaceFraction
//      is our octave space uv coords, after performing the matrix multiplication set
// cornerOffset
//      is relative to the bottom left corner
// inputNoiseTexture
//      is the texture to sample our noise from
// inputTextureDimensions
//      is the size of the input noise texture
float CornerContribution(float2 gridSpaceFraction, float2 cornerOffset, float2 cellUVCoords, RWTexture2D<float4> inputNoiseTexture, uint2 inputTextureDimensions){
    // ======= get the corner vector =======

    // prepare the cell corner pixel location in our input noise
    //  this is where the vectors are
    //  (we include our corner offset in our pixel selecting decision)
    uint2 cellCornerVector_pixel  = uint2( floor(gridSpaceFraction.x+cornerOffset.x)%inputTextureDimensions.x, floor(gridSpaceFraction.y+cornerOffset.y)%inputTextureDimensions.y );

    // get the raw colours
    float4 cellCornerVector_colour  = inputNoiseTexture[cellCornerVector_pixel.xy];

    // turn them in to vectors using trig (lazy)
    float2 cellCornerVector  = inputNoiseAsVector(cellCornerVector_colour);

    // ======= get cell uv difference vector =======

    //  this is the vectors from each corner to where we are in the cell
    float2 cornerUVDifference  = float2(cornerOffset.x - cellUVCoords.x, cornerOffset.y - cellUVCoords.y);

    // ======= get resulting dot product =======
    
    // dot products of difference vector to cooresponding corner vector
    //  we also multiply the UV difference by 2 because our result seems to be in the range of [-0.5,0.5] otherwise
    float resultValue = dot( cornerUVDifference, cellCornerVector );
    
    return resultValue;
}

// ==================================================
// ==================================================


RWTexture2D<float4> ResultImage;
int textureWidth;
int textureHeight;

RWTexture2D<float4> InputNoiseImage;
int noiseTextureWidth;
int noiseTextureHeight;

// cells which we have vectors at the corners
float2 cellCounts1;

// we use this as a transformation matrix to quickly modify the
// uv coordinated of our octave noise input
float4x4 octaveUVMatrix1;




[numthreads(blockWidth,blockHeight,1)]
void PerlinNoiseWithOctaves (uint3 id : SV_DispatchThreadID)
{
    // TODO : have something to check if we're outside the output dimensions
    // convert to floats, we dont like doing that mid equation?
    float2 texelLocation = float2( id.x, id.y);
    float2 outputResolution = float2( textureWidth, textureHeight);
    // to make sure we're retreiving our data correctly
    uint2 inputTextureDimensions = uint2( noiseTextureWidth, noiseTextureHeight );

    // find where we are in the noise texture space
    float4 uvCoords = float4( (texelLocation.x / outputResolution.x), (texelLocation.y / outputResolution.y), 0.0, 1.0 );

    // try using our new style of figuring it out
    float4 gridPositionFraction1 = mul(octaveUVMatrix1,uvCoords);

    // make sure that we're within the grid
    //  modulo is incase we were given some weird location
    // float2 gridPositionFraction = float2(uvCoords.x%1.0*cellCounts1.x, uvCoords.y%1.0*cellCounts1.y );

    // now find the cell locations
    // the ends should still continue all the way up to 0.999999999999 and then go back to 0.0 anyway
    float2 cellUV1 = float2( gridPositionFraction1.x%1.0, gridPositionFraction1.y%1.0 );
    // this is for interpolating our corners together
    float2 smoothCellUV1 = float2(smoothFunction(cellUV1.x),smoothFunction(cellUV1.y));

    // ======= get cell uv difference vectors ====

    // get the corner vectors in "cell UV space"
    float2 cornerUVLocation_bottomLeft  = float2( 0.0, 0.0 );
    float2 cornerUVLocation_bottomRight = float2( 1.0, 0.0 );
    float2 cornerUVLocation_topLeft     = float2( 0.0, 1.0 );
    float2 cornerUVLocation_topRight    = float2( 1.0, 1.0 );

    // ======= get corner contributions ====
    // use da function we made
    float contribution1_bottomLeft  = CornerContribution( gridPositionFraction1.xy, cornerUVLocation_bottomLeft, cellUV1, InputNoiseImage, inputTextureDimensions );
    float contribution1_bottomRight = CornerContribution( gridPositionFraction1.xy, cornerUVLocation_bottomRight, cellUV1, InputNoiseImage, inputTextureDimensions );
    float contribution1_topLeft     = CornerContribution( gridPositionFraction1.xy, cornerUVLocation_topLeft, cellUV1, InputNoiseImage, inputTextureDimensions );
    float contribution1_topRight    = CornerContribution( gridPositionFraction1.xy, cornerUVLocation_topRight, cellUV1, InputNoiseImage, inputTextureDimensions );

    // ======= interpolate our 4 values ====

    float dotsInterpolated1 = bilinearInterpolation(contribution1_bottomLeft, contribution1_bottomRight, contribution1_topLeft, contribution1_topRight, smoothCellUV1);

    // just take it as it is
    float4 outputColour = float4(dotsInterpolated1,dotsInterpolated1,dotsInterpolated1,1.0);
    

    // save it
    ResultImage[id.xy] = outputColour;
}
