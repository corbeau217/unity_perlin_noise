#define blockWidth 16
#define blockHeight 16
#define noiseregionsize 100

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PerlinNoiseWithOctaves

// ==================================================
// ==================================================

float bilinearInterpolation(float bottomLeft, float bottomRight, float topLeft, float topRight, float2 t){
    // ==== X then Y ====

    // 1 dimensional interpolation across X axis
    float linearBottom = lerp(bottomLeft,bottomRight,t.x);
    float linearTop = lerp(topLeft,topRight,t.x);

    // now interpolate them together to make it 2D
    //  but save it as a variable first because otherwise it does weird stuff during compilation?
    float bilinearXY = lerp(linearBottom,linearTop,t.y);

    // ==== Y then X ====

    // 1 dimensional interpolation across Y axis
    float linearLeft = lerp(bottomLeft,topLeft,t.y);
    float linearRight = lerp(bottomRight,topRight,t.y);

    // now interpolate them together to make it 2D
    //  but save it as a variable first because otherwise it does weird stuff during compilation?
    float bilinearYX = lerp(linearLeft,linearRight,t.x);

    // ==== XY and YX
    float average = (bilinearXY + bilinearYX)/2.0;

    return bilinearXY;
}

float smoothFunction(float t){
    return ((6.0*t - 15.0)*t + 10.0)*t*t*t;
}

float2 inputNoiseAsVector(float4 inputNoiseColour){
    // rounded to 6 decimal places because otherwise it doesnt compile
    float piValue = 3.141593;
    // location we are on the circle in radians from 0 to 2*pi
    float noiseRadians = inputNoiseColour.x * piValue * 2.0;

    // turn them in to vectors using trig (lazy)
    float2 resultVector = float2( cos(noiseRadians), sin(noiseRadians) );

    return resultVector;
}

// ==================================================
// ==================================================

// gridSpaceFraction
//      is our octave space uv coords, after performing the matrix multiplication set
// cornerOffset
//      is relative to the bottom left corner
// inputNoiseTexture
//      is the texture to sample our noise from
// inputTextureDimensions
//      is the size of the input noise texture
float GetCornerContribution(float2 gridSpaceFraction, float2 cornerOffset, float2 cellUVCoords, RWTexture2D<float4> inputNoiseTexture, uint2 inputTextureDimensions){
    // ======= get the corner vector =======

    // prepare the cell corner pixel location in our input noise
    //  this is where the vectors are
    //  (we include our corner offset in our pixel selecting decision)
    uint2 cellCornerVector_pixel  = uint2( floor(gridSpaceFraction.x+cornerOffset.x)%inputTextureDimensions.x, floor(gridSpaceFraction.y+cornerOffset.y)%inputTextureDimensions.y );

    // get the raw colours
    float4 cellCornerVector_colour  = inputNoiseTexture[cellCornerVector_pixel.xy];

    // turn them in to vectors using trig (lazy)
    float2 cellCornerVector  = inputNoiseAsVector(cellCornerVector_colour);

    // ======= get cell uv difference vector =======

    //  this is the vectors from each corner to where we are in the cell
    float2 cornerUVDifference  = float2(cornerOffset.x - cellUVCoords.x, cornerOffset.y - cellUVCoords.y);

    // ======= get resulting dot product =======
    
    // dot products of difference vector to cooresponding corner vector
    //  we also multiply the UV difference by 2 because our result seems to be in the range of [-0.5,0.5] otherwise
    float resultValue = dot( cornerUVDifference, cellCornerVector );
    
    return resultValue;
}

// this is the bulk of our noise fetching code
//  we move this to a separate function so we dont have to repeat each of these lines in subsequent octaves
float4 GetOctaveNoise(float4x4 octaveUVTransformationMatrix, float2 octaveCellCounts, float4 fragCoords, RWTexture2D<float4> inputNoiseTexture, uint2 inputTextureDimensions){
    
    // using matrix math to fetch our octave's grid location using our supplied transformation matrix
    float4 octaveGridSpaceCoord = mul( octaveUVTransformationMatrix, fragCoords );

    // we do this to preemptively solve any issues during indexing that might happen in really high resolution noise sampling
    //  where our position might slightly be over the number of cells we want, also to wrap our octave's grid 
    //  (remove these two lines if you dont want the octave corners to wrap around in their grid spaces)
    octaveGridSpaceCoord.x = octaveGridSpaceCoord.x%octaveCellCounts.x;
    octaveGridSpaceCoord.y = octaveGridSpaceCoord.y%octaveCellCounts.y;


    // now find the cell locations
    // the ends should still continue all the way up to 0.999999999999 and then go back to 0.0 anyway
    float2 cellUVCoords = float2( octaveGridSpaceCoord.x%1.0, octaveGridSpaceCoord.y%1.0 );
    // this is for interpolating our corners together
    float2 smoothCellUVCoords = float2(smoothFunction(cellUVCoords.x),smoothFunction(cellUVCoords.y));

    // ======= get cell uv difference vectors ====

    // get the corner vectors in "cell UV space"
    float2 cornerUVLocation_bottomLeft  = float2( 0.0, 0.0 );
    float2 cornerUVLocation_bottomRight = float2( 1.0, 0.0 );
    float2 cornerUVLocation_topLeft     = float2( 0.0, 1.0 );
    float2 cornerUVLocation_topRight    = float2( 1.0, 1.0 );

    // ======= get corner contributions ====
    // use da function we made
    float contribution1_bottomLeft  = GetCornerContribution( octaveGridSpaceCoord.xy, cornerUVLocation_bottomLeft, cellUVCoords, inputNoiseTexture, inputTextureDimensions );
    float contribution1_bottomRight = GetCornerContribution( octaveGridSpaceCoord.xy, cornerUVLocation_bottomRight, cellUVCoords, inputNoiseTexture, inputTextureDimensions );
    float contribution1_topLeft     = GetCornerContribution( octaveGridSpaceCoord.xy, cornerUVLocation_topLeft, cellUVCoords, inputNoiseTexture, inputTextureDimensions );
    float contribution1_topRight    = GetCornerContribution( octaveGridSpaceCoord.xy, cornerUVLocation_topRight, cellUVCoords, inputNoiseTexture, inputTextureDimensions );

    // ======= interpolate our 4 values ====

    float dotsInterpolated = bilinearInterpolation( contribution1_bottomLeft, contribution1_bottomRight, contribution1_topLeft, contribution1_topRight, smoothCellUVCoords );
    float4 resultingOctaveColour = float4( dotsInterpolated, dotsInterpolated, dotsInterpolated, 1.0 );

    return resultingOctaveColour;
}


// ==================================================
// ==================================================


RWTexture2D<float4> ResultImage;
int textureWidth;
int textureHeight;

RWTexture2D<float4> InputNoiseImage;
int noiseTextureWidth;
int noiseTextureHeight;

// cells which we have vectors at the corners
float2 cellCounts1;

// we use this as a transformation matrix to quickly modify the
// uv coordinated of our octave noise input
float4x4 octaveUVMatrix1;




[numthreads(blockWidth,blockHeight,1)]
void PerlinNoiseWithOctaves (uint3 id : SV_DispatchThreadID)
{
    // TODO : have something to check if we're outside the output dimensions
    // convert to floats, we dont like doing that mid equation?
    float2 texelLocation = float2( id.x, id.y);
    float2 outputResolution = float2( textureWidth, textureHeight);

    // to make sure we're retreiving our data correctly
    uint2 inputTextureDimensions = uint2( noiseTextureWidth, noiseTextureHeight );

    // find where we are in the output texture's uv space
    float4 fragmentCoords = float4( (texelLocation.x / outputResolution.x), (texelLocation.y / outputResolution.y), 0.0, 1.0 );

    // request the noise for that octave
    float4 octaveNoise1 = GetOctaveNoise( octaveUVMatrix1, cellCounts1, fragmentCoords, InputNoiseImage, inputTextureDimensions);

    float4 outputColour = octaveNoise1;
    

    // save it
    ResultImage[id.xy] = outputColour;
}
